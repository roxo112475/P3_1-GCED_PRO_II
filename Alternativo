from linked_ordered_positional_list import LinkedOrderedPositionalList as LOP
from array_ordered_positional_list import ArrayOrderedPositionalList as AOP


def read_orders(path="pedidos.txt"):
    lista_pedidos = []
    with open(path, encoding='utf8') as f:
        for l in f.readlines():
            ls = l.strip().split(",")
            customer, model_name = ls[0], ls[1]
            lista_pedidos.append([model_name, customer])
    return lista_pedidos


def read_parts(path="piezas.txt"):
    try:
        inventario = AOP()
    except NameError:
        inventario = LOP()

    with open(path, encoding='utf8') as f:
        for l in f.readlines():
            ls = l.strip().split(",")
            part_name, qty = ls[0], int(ls[1])
            inventario.add([part_name, qty])

    return inventario


def read_models(path="modelos.txt"):
    catalogo = {}
    with open(path, encoding='utf8') as f:
        for l in f.readlines():
            ls = l.strip().split(",")
            model_name, part_name, qty = ls[0], ls[1], int(ls[2])
            piezas = (part_name, qty)

            if model_name not in catalogo.keys():
                try:
                    catalogo[model_name] = LOP()
                except NameError:
                    catalogo[model_name] = AOP()

            catalogo[model_name].add(piezas)
    return catalogo


def procesar_pedidos(lista_pedidos: list, catalogo):
    while len(lista_pedidos) != 0:
        pedido = lista_pedidos.pop(0)
        model_name, customer = pedido[0], pedido[1]
        print("-------------")
        print("Nuevo pedido; Modelo: ", model_name, " | Cliente: ", customer)
        if model_name not in catalogo:
            print("Pedido NO atendido. Modelo: ", model_name, "fuera del catálogo.")
            print("-------------")
            return None
        else:
            print("-------------")
            print(f"Modelo: {model_name}")
            for componentes in catalogo[model_name]:
                print(*componentes, sep=" - ")
            print("-------------\n")
            return model_name


def comprobacion(en_construccion: str, inventario, catalogo):
    if en_construccion in catalogo.keys():
        piezas_faltantes = []
        resta_piezas = []
        modelo = catalogo.get(en_construccion)

        pos = modelo.first()
        while pos is not None:
            pieza, cantidad = modelo.get_element(pos)
            pos = modelo.after(pos)

            inv_pos = inventario.first()
            found = False

            while inv_pos is not None:
                pieza_inv = inventario.get_element(inv_pos)
                if pieza_inv[0] == pieza:
                    found = True
                    if pieza_inv[1] >= cantidad:
                        resta_piezas.append([pieza_inv[0], cantidad])
                    else:
                        piezas_faltantes.append([pieza_inv[0], cantidad - pieza_inv[1]])
                    break
                inv_pos = inventario.after(inv_pos)

            if not found:
                piezas_faltantes.append([pieza, cantidad])

        if len(piezas_faltantes) > 0:
            frase = "\n".join(f"{pieza[0]}: {pieza[1]}" for pieza in piezas_faltantes)
            print(f"\nPedido NO atendido: Faltan:")
            print(frase, "\n")
            catalogo.pop(en_construccion)
            print(f"El modelo {en_construccion} ha sido eliminado del catálogo")
            return None
        else:
            return resta_piezas


def eliminar_modelos_dependientes(pieza, catalogo):
    modelos_a_eliminar = []

    for modelo, lista_piezas in catalogo.items():
        pos = lista_piezas.first()
        while pos is not None:
            pieza_modelo, _ = lista_piezas.get_element(pos)
            if pieza_modelo == pieza:
                modelos_a_eliminar.append(modelo)
                break
            pos = lista_piezas.after(pos)

    for modelo in modelos_a_eliminar:
        catalogo.pop(modelo)
        print(f"Eliminado: Modelo {modelo} dependiente")


def ensamblar(inventario, en_construccion, catalogo):
    resta_piezas = comprobacion(en_construccion, inventario, catalogo)
    if resta_piezas is not None:
        for piezas in resta_piezas:
            nombre, cantidad = piezas
            inv_pos = inventario.first()

            while inv_pos is not None:
                pieza_inv = inventario.get_element(inv_pos)
                if pieza_inv[0] == nombre:
                    pieza_inv[1] -= cantidad
                    if pieza_inv[1] == 0:
                        print(f"Eliminada: Pieza {nombre}")
                        inventario.delete(inv_pos)
                        eliminar_modelos_dependientes(nombre, catalogo)
                    break
                inv_pos = inventario.after(inv_pos)
        print(f"Pedido {en_construccion} atendido.\n")


if __name__ == "__main__":
    lista_pedidos = read_orders()
    inventario = read_parts()
    catalogo = read_models()

    while len(lista_pedidos) > 0:
        en_construccion = procesar_pedidos(lista_pedidos, catalogo)
        if en_construccion:
            ensamblar(inventario, en_construccion, catalogo)

        print("---STOCK---\n")
        for elementos in inventario:
            print(f"{elementos[0]}: {elementos[1]}")
        print()

        print("-----CATÁLOGO----\n")
        for modelo, lista in catalogo.items():
            print("Modelo:", modelo)
            frase = "| ".join(f"{pieza[0]}: {pieza[1]}" for pieza in lista)
            print(f"{frase}\n")
